1. Проанализируйте задания предыдущих уроков. В каких случаях необходима была явная передача указателя в качестве входных параметров и возвращаемых результатов или в качестве приёмника в методах? В каких случаях мы фактически имеем дело с указателями при передаче параметров, хотя явно их не указываем?

В Go при присваивании значения копируются, т.е. если нам не нужно хранить в переменной изначальное значение мы можем работать с указателем на переменную, который будет изменять саму переменную не создавая копии. В случае с большими структурами типа массивов, слайсов это экономит память. Также при работе со структурами мы таким образом можем привязать метод к указателю на структуру. 
В 4 дз про сортировку можно было использовать указатели, так как мы работали со слайсом.
Мы имеем дело с указателем при передаче параметров, явно его не указывая при работе со слайсом, так как один из трех компонентов слайса это указатель на первый элемент массива. Также при работе с map.


2. Для арифметического умножения и разыменования указателей в Go используется один и тот же      символ — оператор (*). Как вы думаете, как компилятор Go понимает, в каких случаях в          выражении имеется в виду умножение, а в каких — разыменование указателя?

Для реализации арифметической операции умножения необходимы два операнда, необходимо соблюдать последовательность операторов и операндов, например:
    z:=x*y - умножение
    z*=x - унарное умножение, операнд z должен быть заранее проинициализирован 
    z:=*n - разыменовывание указателя (получение значения из участка памяти, на которое указывает указатель), если z был ранее объявлен, то корректна запись z=*n: символ * идет непосредственно перед переменной в которую передана ссылка и перед ним НЕТ еще одного операнда, иначе для компилятора это будет являться умножением, как в первом примере.
    В зависимости от того сколько ссылок было сделано ранее возможна и такая запись:
    a := 50
	b := &a
	*b++
	c := &b
	**c++
	d := &c
	***d++
	e := &d
	****e++
	fmt.Print(****e) //54
    
    